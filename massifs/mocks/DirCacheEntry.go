// Code generated by mockery v2.42.2. DO NOT EDIT.

package mocks

import (
	massifs "github.com/datatrails/go-datatrails-merklelog/massifs"
	mock "github.com/stretchr/testify/mock"
)

// DirCacheEntry is an autogenerated mock type for the DirCacheEntry type
type DirCacheEntry struct {
	mock.Mock
}

// GetInfo provides a mock function with given fields:
func (_m *DirCacheEntry) GetInfo() massifs.EntryInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 massifs.EntryInfo
	if rf, ok := ret.Get(0).(func() massifs.EntryInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(massifs.EntryInfo)
	}

	return r0
}

// GetSeal provides a mock function with given fields: c, massifIndex
func (_m *DirCacheEntry) GetSeal(c massifs.DirCache, massifIndex uint64) (*massifs.SealedState, error) {
	ret := _m.Called(c, massifIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetSeal")
	}

	var r0 *massifs.SealedState
	var r1 error
	if rf, ok := ret.Get(0).(func(massifs.DirCache, uint64) (*massifs.SealedState, error)); ok {
		return rf(c, massifIndex)
	}
	if rf, ok := ret.Get(0).(func(massifs.DirCache, uint64) *massifs.SealedState); ok {
		r0 = rf(c, massifIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*massifs.SealedState)
		}
	}

	if rf, ok := ret.Get(1).(func(massifs.DirCache, uint64) error); ok {
		r1 = rf(c, massifIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadMassif provides a mock function with given fields: c, massifIndex
func (_m *DirCacheEntry) ReadMassif(c massifs.DirCache, massifIndex uint64) (*massifs.MassifContext, error) {
	ret := _m.Called(c, massifIndex)

	if len(ret) == 0 {
		panic("no return value specified for ReadMassif")
	}

	var r0 *massifs.MassifContext
	var r1 error
	if rf, ok := ret.Get(0).(func(massifs.DirCache, uint64) (*massifs.MassifContext, error)); ok {
		return rf(c, massifIndex)
	}
	if rf, ok := ret.Get(0).(func(massifs.DirCache, uint64) *massifs.MassifContext); ok {
		r0 = rf(c, massifIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*massifs.MassifContext)
		}
	}

	if rf, ok := ret.Get(1).(func(massifs.DirCache, uint64) error); ok {
		r1 = rf(c, massifIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadMassifStart provides a mock function with given fields: c, logfile
func (_m *DirCacheEntry) ReadMassifStart(c massifs.DirCache, logfile string) (massifs.MassifStart, error) {
	ret := _m.Called(c, logfile)

	if len(ret) == 0 {
		panic("no return value specified for ReadMassifStart")
	}

	var r0 massifs.MassifStart
	var r1 error
	if rf, ok := ret.Get(0).(func(massifs.DirCache, string) (massifs.MassifStart, error)); ok {
		return rf(c, logfile)
	}
	if rf, ok := ret.Get(0).(func(massifs.DirCache, string) massifs.MassifStart); ok {
		r0 = rf(c, logfile)
	} else {
		r0 = ret.Get(0).(massifs.MassifStart)
	}

	if rf, ok := ret.Get(1).(func(massifs.DirCache, string) error); ok {
		r1 = rf(c, logfile)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadSeal provides a mock function with given fields: c, fileName
func (_m *DirCacheEntry) ReadSeal(c massifs.DirCache, fileName string) (*massifs.SealedState, error) {
	ret := _m.Called(c, fileName)

	if len(ret) == 0 {
		panic("no return value specified for ReadSeal")
	}

	var r0 *massifs.SealedState
	var r1 error
	if rf, ok := ret.Get(0).(func(massifs.DirCache, string) (*massifs.SealedState, error)); ok {
		return rf(c, fileName)
	}
	if rf, ok := ret.Get(0).(func(massifs.DirCache, string) *massifs.SealedState); ok {
		r0 = rf(c, fileName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*massifs.SealedState)
		}
	}

	if rf, ok := ret.Get(1).(func(massifs.DirCache, string) error); ok {
		r1 = rf(c, fileName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewDirCacheEntry creates a new instance of DirCacheEntry. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDirCacheEntry(t interface {
	mock.TestingT
	Cleanup(func())
}) *DirCacheEntry {
	mock := &DirCacheEntry{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
